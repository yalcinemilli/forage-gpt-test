import { NextRequest, NextResponse } from 'next/server';

const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const MAILGUN_API_KEY = process.env.MAILGUN_API_KEY;
const MAILGUN_DOMAIN = process.env.MAILGUN_DOMAIN || 'mg.forage-clothing.com';
const ZENDESK_EMAIL = process.env.ZENDESK_EMAIL;
const ZENDESK_TOKEN = process.env.ZENDESK_TOKEN;
const ZENDESK_SUBDOMAIN = process.env.ZENDESK_SUBDOMAIN || 'forage-clothing';
const FROM_EMAIL = 'support@forage-clothing.com';
const LAGER_EMAIL = 'hey@markmaurer.de';

interface ZendeskWebhook {
  detail: {
    id: string;
    subject?: string;
    description?: string;
    requester_id?: string;
  };
}

interface OpenAIResponse {
  choices: Array<{
    message: {
      content: string;
    };
  }>;
}

async function getRequester(requesterId: string) {
  const res = await fetch(`https://${ZENDESK_SUBDOMAIN}.zendesk.com/api/v2/users/${requesterId}.json`, {
    headers: {
      Authorization: `Basic ${Buffer.from(`${ZENDESK_EMAIL}/token:${ZENDESK_TOKEN}`).toString('base64')}`,
    },
  });

  if (!res.ok) throw new Error('Fehler beim Abruf der Requester-Daten');

  const data = await res.json();
  return {
    name: data.user.name,
    email: data.user.email,
  };
}

async function analyzeIntent(comment: string, subject: string): Promise<{
  intent: 'stornierung' | 'adress√§nderung' | 'keine';
  order_number?: string;
  raw_response?: string;
} | null> {
  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${OPENAI_API_KEY}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: 'gpt-4o',
      messages: [
        {
          role: 'system',
          content: `Du bist ein Intent-Filter f√ºr unseren Kundenservice.

Deine Aufgabe:
Analysiere die Nachricht eines Kunden und erkenne seinen Wunsch. Es gibt drei m√∂gliche Kategorien:

1. **Adress√§nderung** ‚Äì Der Kunde m√∂chte die Lieferadresse √§ndern oder hat aus Versehen eine falsche Adresse eingegeben. Es reicht, wenn er sinngem√§√ü darum bittet, an eine andere Adresse zu liefern (z.‚ÄØB. "Ich habe aus Versehen an die falsche Adresse bestellt", "Bitte an Lagerweg 12 schicken", "K√∂nnt ihr das an meine neue Adresse schicken?" etc.).

2. **Stornierung** ‚Äì Der Kunde m√∂chte seine Bestellung nicht mehr erhalten. Auch Formulierungen wie "bitte abbrechen", "nicht mehr liefern", "stornieren", "kann ich noch stornieren?" fallen darunter.

3. **keine** ‚Äì Wenn weder Adress√§nderung noch Stornierung eindeutig oder sinngem√§√ü erkennbar ist.

Zus√§tzlich: Wenn eine Bestellnummer (z.‚ÄØB. eine 6-stellige Zahl wie 123456) im Betreff oder in der Nachricht enthalten ist, gib diese unter ‚Äûorder_number‚Äú zur√ºck.

Antworte **ausschlie√ülich** im folgenden JSON-Format:
{
  "intent": "stornierung" | "adress√§nderung" | "keine",
  "order_number": "123456" // optional, falls erkennbar
}`,
        },
        {
          role: 'user',
          content: `Betreff: ${subject.trim().replace(/\s+/g, ' ')}

Nachricht: ${comment.trim().replace(/\s+/g, ' ')}`,
        },
      ],
      temperature: 0.4,
    }),
  });

  if (!response.ok) throw new Error(`OpenAI Fehler: ${response.status}`);
  const data: OpenAIResponse = await response.json();
  try {
    const raw = data.choices[0].message.content.trim();
    const jsonMatch = raw.match(/\{[\s\S]*\}/);
    if (!jsonMatch) return { intent: 'keine', raw_response: raw };

    try {
      const parsed = JSON.parse(jsonMatch[0]);
      return { ...parsed, raw_response: raw };
    } catch (e) {
      console.error('‚ùå JSON parse error', e, 'Antwort war:', raw);
      return { intent: 'keine', raw_response: raw };
    }
  } catch {
    return null;
  }
}

async function sendLagerEmail(type: 'stornierung' | 'adress√§nderung', name: string, order: string, comment: string, subject: string, email: string) {
  
  const subjectLine = type === 'stornierung' ? `Stornierung: Bestellung ${order}` : `Adress√§nderung: Bestellung ${order}`;
  const text = `Hallo Lager-Team,

Der Kunde ${name} hat eine ${type === 'stornierung' ? 'Stornierung' : 'Adress√§nderung'} angefragt.

Betreff des Tickets: ${subject}
Bestellnummer: ${order}
Kunden-E-Mail: ${email}
Kommentar:
${comment}

Bitte entsprechend bearbeiten.

Liebe Gr√º√üe
Dein FOR√ÄGE System`;

  const body = new URLSearchParams({
    from: `FOR√ÄGE Support <${FROM_EMAIL}>`,
    to: LAGER_EMAIL,
    subject: subjectLine,
    text,
  });

  const res = await fetch(`https://api.eu.mailgun.net/v3/${MAILGUN_DOMAIN}/messages`, {
    method: 'POST',
    headers: {
      Authorization: `Basic ${Buffer.from(`api:${MAILGUN_API_KEY}`).toString('base64')}`,
      'Content-Type': 'application/x-www-form-urlencoded',
    },
    body,
  });

  if (!res.ok) throw new Error(`Mailgun Fehler: ${res.status}`);
}

async function addZendeskComment(ticketId: number, comment: string): Promise<void> {
  const url = `https://${ZENDESK_SUBDOMAIN}.zendesk.com/api/v2/tickets/${ticketId}/comments.json`;

  const res = await fetch(url, {
    method: 'POST',
    headers: {
      Authorization: `Basic ${Buffer.from(`${ZENDESK_EMAIL}/token:${ZENDESK_TOKEN}`).toString('base64')}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      body: comment,
      public: false,
    }),
  });

  if (!res.ok) {
    const text = await res.text();
    console.error('‚ùå Fehler beim Hinzuf√ºgen des internen Kommentars:', res.status, text);
    throw new Error('Kommentar konnte nicht hinzugef√ºgt werden');
  }
}

export async function POST(request: NextRequest) {
  try {
    const payload: ZendeskWebhook = await request.json();
    const ticket_id = Number(payload.detail?.id);
    const subject = payload.detail?.subject || 'Kein Betreff angegeben';
    const comment = payload.detail?.description || '';

    if (!ticket_id || !comment.trim() || !payload.detail.requester_id) {
      return NextResponse.json({ error: 'Ticket ID, Kommentar und Requester ID sind erforderlich' }, { status: 400 });
    }

    const { name, email } = await getRequester(payload.detail.requester_id);

    const analysis = await analyzeIntent(comment, subject);

    if (!analysis || analysis.intent === 'keine') {
      return NextResponse.json(
        { success: true, 
          intent: 'keine', 
          debug: {
            subject,
            comment,
            name,
            email,
            requester_id: payload.detail.requester_id,
            openai_response: analysis?.raw_response || 'Keine Antwort',
          },
        }
      );
    }

    const resolvedOrderNumber = analysis.order_number || 'Unbekannt';


    
    await sendLagerEmail(
      analysis.intent,
      name,
      resolvedOrderNumber,
      comment,
      subject,
      email
    );

    const ticketNote = analysis.intent === 'stornierung'
  ? 'ü§ñ Automatisch erkannt: Stornierung angefragt.'
  : 'ü§ñ Automatisch erkannt: Adress√§nderung angefragt.';
await addZendeskComment(ticket_id, ticketNote);

    return NextResponse.json({ success: true, intent: analysis.intent });
  } catch (error) {
    console.error('Fehler im Webhook:', error);
    return NextResponse.json({ error: 'Serverfehler', details: (error as Error).message }, { status: 500 });
  }
}

export async function GET() {
  return NextResponse.json({ status: 'ok', timestamp: new Date().toISOString() });
}
